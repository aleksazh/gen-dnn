/*******************************************************************************
* Copyright 2019-2020 Intel Corporation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*******************************************************************************/

#ifndef DNNL_CONFIG_H
#define DNNL_CONFIG_H

#include "dnnl_types.h"

/// @cond DO_NOT_DOCUMENT_THIS

// All symbols shall be internal unless marked as DNNL_API
#if defined _WIN32 || defined __CYGWIN__
#define DNNL_HELPER_DLL_IMPORT __declspec(dllimport)
#define DNNL_HELPER_DLL_EXPORT __declspec(dllexport)
#else
#if __GNUC__ >= 4
#define DNNL_HELPER_DLL_IMPORT __attribute__((visibility("default")))
#define DNNL_HELPER_DLL_EXPORT __attribute__((visibility("default")))
#else
#define DNNL_HELPER_DLL_IMPORT
#define DNNL_HELPER_DLL_EXPORT
#endif
#endif

#ifdef DNNL_DLL
#ifdef DNNL_DLL_EXPORTS
#define DNNL_API DNNL_HELPER_DLL_EXPORT
#else
#define DNNL_API DNNL_HELPER_DLL_IMPORT
#endif
#else
#define DNNL_API
#endif

#if defined(__GNUC__)
#define DNNL_DEPRECATED __attribute__((deprecated))
#elif defined(_MSC_VER)
#define DNNL_DEPRECATED __declspec(deprecated)
#else
#define DNNL_DEPRECATED
#endif

/// @endcond

// clang-format off

/// @addtogroup cmake_build cmake build options
//@{

///@addtogroup cmake_supported cmake supported options
/// Not all options are exposed as config variables, however all
/// nonstandard supported build options should appear in DNNL_BUILD_STRING
//@{

/// [info] DNNL cmake Build Target String.
/// This also records non-standard 'unsupported' options
/** \note some options may be exposed only in the build string.
 * Some build options will appear only via the build string. */
#cmakedefine DNNL_BUILD_STRING "${DNNL_BUILD_STRING}"

/// DNNL CPU threading runtime
#cmakedefine DNNL_CPU_THREADING_RUNTIME DNNL_RUNTIME_${DNNL_CPU_THREADING_RUNTIME}

/// DNNL CPU engine runtime
#cmakedefine DNNL_CPU_RUNTIME DNNL_RUNTIME_${DNNL_CPU_RUNTIME}

/// DNNL GPU engine runtime
#cmakedefine DNNL_GPU_RUNTIME DNNL_RUNTIME_${DNNL_GPU_RUNTIME}

/// DNNL CPU enable runtime cpu dispatch.
///   respect env DNNL_MAX_CPU_ISA, enable dnnl_set_max_cpu_isa(dnnl_cpu_isa_t)
#ifndef DNNL_ENABLE_MAX_CPU_ISA /* XXX remove from cmake files XXX */
#cmakedefine DNNL_ENABLE_MAX_CPU_ISA
#endif

/// DNNL verbosity, from `cmake -DDNNL_VERBOSE={NONE|DEFAULT|EXTRA}`.
/// This is '1' at levels above NONE, which allows verbosity
/// \ref dev-guide-verbose "levels 0[default, quiet], 1 and 2".
#define DNNL_VERBOSE ${_DNNL_VERBOSE}

/// OS/compiler workaround for CPU scratchpad (0/1 values)
#define DNNL_USE_STATIC_THREAD_LOCAL_OBJECTS ${DNNL_USE_STATIC_THREAD_LOCAL_OBJECTS}
#define DNNL_BUG_VALUE_INITIALIZATION        ${DNNL_BUG_VALUE_INITIALIZATION}

//@}

/// 
/// @addtogroup cmake_extra Other building options (subject to change)
//@{

/** DNNL CPU build target 1,2,etc = x86, ve, etc.
 * Cmake sets this automatically based on CMAKE_SYSTEM_PROCESSOR.
 * So almost always it will have the value \c DNN_CPU_X86.
 */
#cmakedefine DNNL_CPU ${DNNL_CPU}

/// cpu target expand capability from VANILLA-->ANY-->(cpu-specific)-->ALL.
/// The cmake default is -DDNNL_ISA=ALL, which means "provide full support".
/// During compilation `\#if DNNL_ISA == DNNL_ISA_ALL` will be true.
/** \internal
 * This may prune \b some implementations from \c cpu_engine, but is non-normative.
 * For example, jit\_uni\_ drivers may circumvent this, and even
 * \ref dispatcher_control.md may not always suffice to force particular
 * code variants to run.
 */
#cmakedefine DNNL_ISA ${DNNL_ISA_VALUE}

// DNNL_ISA==DNNL_ISA_VANILLA build is missing many bf16 impls, but
// removing bf16 support from src,examples,tests touched 79 files.
// Option can be reintroduced as separate PR [kruus]
// #define DNNL_ENABLE_BFLOAT16 ${DNNL_ENABLE_BFLOAT16_01}

/// [debug] some targets cannot compile a correct ref impl yet.
#define DNNL_ENABLE_RNN ${DNNL_ENABLE_RNN_01}

/// [debug] trace cpu_engine 'create' attempts.
/** Activates extra code when built with `cmake -DDNNL_VERBOSE=EXTRA`,
 * which allows extra output at additional verbosity levels
 * \ref dev-guide-verbose "levels 3 and 4".
 *
 * This allows tracing how cpu_engine skips various impls as it tries
 * to create a primitive. Primitive creation will slow down even more.
 * \ref consistency.hpp can help pinpoint the precise reason a
 * particular init() failed. */
#define DNNL_VERBOSE_EXTRA ${_DNNL_VERBOSE_EXTRA}

/// [at own risk] gemm via MKL library.
/// May provide support for packed and integer gemm variations not yet
/// available via jit.
#cmakedefine DNNL_USE_MKL ${_DNNL_USE_MKL}

/// [at own risk] gemm via OS CBLAS (also implied by DNNL_USE_MKL)
/// New: dnnl now comes with a reasonable reference gemm impl now,
///      capable of running the tests in reasonable time frame,
///      even without having cmake look for a cblas library.
#cmakedefine DNNL_USE_CBLAS ${_DNNL_USE_CBLAS}

//@}
//@}

/// @addtogroup cmake_build_constants cmake build constants
//@{
/// @group
/// target processor
//@{
#cmakedefine DNNL_CPU_X86 ${DNNL_CPU_X86}
#cmakedefine DNNL_CPU_VE  ${DNNL_CPU_VE}
//#cmakedefine DNNL_CPU_SX  ${DNNL_CPU_SX} /* deprecated */
//@}

/// @group
/// CPU_ISA_FOO cmake options describe flavors of the cpu build.
/// May also serve to add \e extra capabilities like JIT,
/// or external library features to the basic VANILLA builds.
///@{
/// @group
/// all cpus support a few common settings.
///@{
/// Means "C/C++ code only, please".
#cmakedefine DNNL_ISA_VANILLA ${DNNL_ISA_VANILLA}

/** Also provides a builtin gemm reference implementation, so many common
 * convolutions can run at decent speed during tests. */
#cmakedefine DNNL_ISA_ANY     ${DNNL_ISA_ANY}

/// pull out all the stops, all options & external support allowed.
#cmakedefine DNNL_ISA_ALL     ${DNNL_ISA_ALL}
///@}

/** @group
 * max x86 jit instruction set support.
 * This might not be respected by jit uni [unified] drivers CHECKME.
 * DNNL_ISA_ALL, on x86 cpu will be equivalent to DNNL_ISA_X86_ALL
 */
///@{
#cmakedefine DNNL_ISA_X86              ${DNNL_ISA_X86}
#cmakedefine DNNL_ISA_SSE41            ${DNNL_ISA_SSE41}
#cmakedefine DNNL_ISA_AVX              ${DNNL_ISA_AVX}
#cmakedefine DNNL_ISA_AVX2             ${DNNL_ISA_AVX2}
#cmakedefine DNNL_ISA_AVX512_MIC       ${DNNL_ISA_AVX512_MIC}
#cmakedefine DNNL_ISA_AVX512_MIC_4OPS  ${DNNL_ISA_AVX512_MIC_4OPS}
#cmakedefine DNNL_ISA_AVX512_CORE      ${DNNL_ISA_AVX512_CORE}
#cmakedefine DNNL_ISA_AVX512_CORE_VNNI ${DNNL_ISA_AVX512_CORE_VNNI}
#cmakedefine DNNL_ISA_AVX512_CORE_BF16 ${DNNL_ISA_AVX512_CORE_BF16}
#cmakedefine DNNL_ISA_X86_ALL          ${DNNL_ISA_X86_ALL}
///@}
/// @group
/// ve isa settings govern jit instruction set support
///@{
#cmakedefine DNNL_ISA_VE     ${DNNL_ISA_VE}    // equiv to vanilla
#cmakedefine DNNL_ISA_VEDNN  ${DNNL_ISA_VEDNN}
#cmakedefine DNNL_ISA_VEJIT  ${DNNL_ISA_VEJIT}
#cmakedefine DNNL_ISA_VE_ALL ${DNNL_ISA_VE_ALL}
///@}
///@}

/// @defgroup cmake_bool handy conditional tests for cmake build target
/** \note \ref cpu_target.h can these into shorter internal versions.
 * They expand to either 0 or 1. */
//@{
/** Turn conditions into 0/1 value.  Then -E compile and -dM will show a 0 or 1
 * values (easier to read) XXX verify function CHECKME. */
#define DNNL_EXPAND_01(...) !!(__VA_ARGS__)

/** No x86 jit -- only uses <em>reference implementation</em> code.  This is a
 * good build target to begin supporting non-x86 chipsets. Typical customization
 * issues for cross-compilers will be:
 *
 * - providing a cmake TOOLCHAIN file
 * - dealing with atomic support and timer routines.  Maybe you need some minimal
 *   amount of inline assembler for this.
 * - Although DNNL reference gemm is now pretty fast, you should set cache sizes
 *   for your target correctly.
 * - You may also want to use some system blas
 *   - (DNNL_EXTERNAL_GEMM XXX what did I call it?)
 *
 * - note: DNNL_a.k.a. TARGET_XXX
 * \todo not all features are available with vanilla implementation
 * (DNNL_ISA==DNL_ISA_VANILLA)
 */
#define DNNL_TARGET_VANILLA (DNNL_ISA == DNNL_ISA_VANILLA || DNNL_CPU == DNNL_CPU_VE/*to start debug*/)
// not yet sure if we DNNL_ISA_ANY should be supported XXX all vs any is always confusing XXX
//#define DNNL_TARGET_VANILLA (DNNL_ISA == DNNL_ISA_VANILLA || (DNNL_CPU == DNNL_CPU_VE && DNNL_ISA <= DNNL_ISA_ANY))

/** Can use DNNL_TARGET_VANILLA == (DNNL_TARGET_X86 && !DNNL_TARGET_X86_JIT).
 * \detail dnnl impls often include \ref src/common/cpu_target.h and will write
 *         `TARGET_X86` for readability. */
#define DNNL_TARGET_X86     (DNNL_CPU == DNNL_CPU_X86)
#define DNNL_TARGET_X86_JIT (DNNL_TARGET_X86 && DNNL_ISA >= DNNL_ISA_ANY && DNNL_ISA <= DNNL_ISA_ALL)

#define DNNL_TARGET_VE      (DNNL_CPU == DNNL_CPU_VE)
#define DNNL_TARGET_VEDNN   (DNNL_TARGET_VE && DNNL_ISA >= DNNL_ISA_VEDNN && DNNL_ISA <= DNNL_ISA_ALL)
#define DNNL_TARGET_VEJIT   (DNNL_TARGET_VE && DNNL_ISA >= DNNL_ISA_VEJIT && DNNL_ISA <= DNNL_ISA_ALL)

//#define DNNL_TARGET_SX // \deprecated
#if DNNL_TARGET_X86_JIT
//#warning "DNNL_TARGET_X86_JIT is TRUE"
#else
//#warning "DNNL_TARGET_X86_JIT is FALSE"
#endif
//@}

// clang-format on

#if DNNL_TARGET_X86 + DNNL_TARGET_VE == 0
#error "unknown target cpu.  no DNNL_TARGET_foo was set"
#endif
#if DNNL_TARGET_X86 + DNNL_TARGET_VE != 1
#error "cannot have more than one target cpu"
#endif

#if defined(DNNL_CPU_RUNTIME) && defined(DNNL_GPU_RUNTIME)
#if (DNNL_CPU_RUNTIME == DNNL_RUNTIME_NONE) \
        || (DNNL_CPU_RUNTIME == DNNL_RUNTIME_OCL)
#error "Unexpected DNNL_CPU_RUNTIME"
#endif
#if (DNNL_GPU_RUNTIME != DNNL_RUNTIME_NONE) \
        && (DNNL_GPU_RUNTIME != DNNL_RUNTIME_OCL)
#error "Unexpected DNNL_GPU_RUNTIME"
#endif
#else
#error "BOTH DNNL_CPU_RUNTIME and DNNL_GPU_RUNTIME must be defined"
#endif

// vim: et ts=4 sw=4 cindent cino=+2s,^=l0,\:0,N-s syntax=cpp.doxygen
#endif
