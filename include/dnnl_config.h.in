/*******************************************************************************
* Copyright 2019-2020 Intel Corporation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*******************************************************************************/

#ifndef DNNL_CONFIG_H
#define DNNL_CONFIG_H

#include "dnnl_types.h"

/// @cond DO_NOT_DOCUMENT_THIS

// All symbols shall be internal unless marked as DNNL_API
#if defined _WIN32 || defined __CYGWIN__
#define DNNL_HELPER_DLL_IMPORT __declspec(dllimport)
#define DNNL_HELPER_DLL_EXPORT __declspec(dllexport)
#else
#if __GNUC__ >= 4
#define DNNL_HELPER_DLL_IMPORT __attribute__((visibility("default")))
#define DNNL_HELPER_DLL_EXPORT __attribute__((visibility("default")))
#else
#define DNNL_HELPER_DLL_IMPORT
#define DNNL_HELPER_DLL_EXPORT
#endif
#endif

#ifdef DNNL_DLL
#ifdef DNNL_DLL_EXPORTS
#define DNNL_API DNNL_HELPER_DLL_EXPORT
#else
#define DNNL_API DNNL_HELPER_DLL_IMPORT
#endif
#else
#define DNNL_API
#endif

#if defined(__GNUC__)
#define DNNL_DEPRECATED __attribute__((deprecated))
#elif defined(_MSC_VER)
#define DNNL_DEPRECATED __declspec(deprecated)
#else
#define DNNL_DEPRECATED
#endif

/// @endcond

/// @addtogroup dnnl_api
//@{
/// [info] DNNL cmake Build Target String.
/// To manage experimental builds, this string reports any non-standard
/// <em>expert use only</em> options.  \e tests and \e benchdnn will
/// print this string to avoid confusion in log files.
#cmakedefine DNNL_BUILD_STRING "${DNNL_BUILD_STRING}"
//@}

// clang-format off

/// @addtogroup cmake_build cmake build options
//@{

///@addtogroup cmake_supported cmake supported options
/// Not all options are exposed as config variables, however all
/// nonstandard supported build options should appear in DNNL_BUILD_STRING
//@{

/// DNNL CPU threading runtime
#cmakedefine DNNL_CPU_THREADING_RUNTIME DNNL_RUNTIME_${DNNL_CPU_THREADING_RUNTIME}

/// DNNL CPU engine runtime
#cmakedefine DNNL_CPU_RUNTIME DNNL_RUNTIME_${DNNL_CPU_RUNTIME}

/// DNNL GPU engine runtime
#cmakedefine DNNL_GPU_RUNTIME DNNL_RUNTIME_${DNNL_GPU_RUNTIME}

/// DNNL CPU enable runtime cpu dispatch.
///   respect env DNNL_MAX_CPU_ISA, enable dnnl_set_max_cpu_isa(dnnl_cpu_isa_t)
#cmakedefine DNNL_ENABLE_MAX_CPU_ISA

/// \ref dev-guide-verbose 0[default, quiet] or 1".
#define DNNL_VERBOSE ${DNNL_VERBOSE_01}

//@}

/// 
/// @addtogroup cmake_extra Other building options (subject to change)
//@{

/** DNNL CPU build target 1,2,etc = x86, ve, etc.
 * Cmake sets this automatically based on CMAKE_SYSTEM_PROCESSOR.
 * So almost always it will have the value \c DNN_CPU_X86.
 */
#cmakedefine DNNL_CPU ${DNNL_CPU}

/// cpu target expand capability from VANILLA-->ANY-->(cpu-specific)-->ALL.
/// The cmake default is -DDNNL_ISA=ALL, which means "support all cpu features".
/** \internal
 * DNNL_ISA_ may prune \b some implementations from \c cpu_engine, but is
 * non-normative.  For example, jit\_uni\_ drivers may circumvent this, so
 * \ref dispatcher_control.md is a more general approach.
 */
#cmakedefine DNNL_ISA ${DNNL_ISA_VALUE}

/// gemm via MKL library.
/// May provide packed and integer gemm variations.
#cmakedefine USE_MKL

// ejk REMOVED gemm via OS CBLAS (also implied by DNNL_USE_MKL)
//#cmakedefine DNNL_USE_CBLAS
// ejk REMOVED cmake test for compiler bug (for simplicity)
#if !defined(DNNL_VALUE_INITIALIZATION_BUG) && defined(__ve)
#define DNNL_VALUE_INITIALIZATION_BUG 1
#elif !defined(DNNL_VALUE_INITIALIZATION_BUG)
#define DNNL_VALUE_INITIALIZATION_BUG 0
#endif

//@}
//@}

/// @addtogroup cmake_build_constants cmake build constants
//@{
// target cpu constants
#cmakedefine DNNL_CPU_X86 ${DNNL_CPU_X86}
#cmakedefine DNNL_CPU_VE  ${DNNL_CPU_VE}

/// Portable C/C++ code [cross-platform].
#cmakedefine DNNL_ISA_VANILLA   ${DNNL_ISA_VANILLA}

/// VANILLA, but allowing most basic ISA for the CPU [cross-platform]
#cmakedefine DNNL_ISA_ANY       ${DNNL_ISA_ANY}

/// ALL cpu features supported in libdnnl [cross-platfrom]
#cmakedefine DNNL_ISA_ALL       ${DNNL_ISA_ALL}

/** @group
 * constant values for all known CPU/ISA combinations */
///@{
#cmakedefine DNNL_ISA_X86       ${DNNL_ISA_X86}
#cmakedefine DNNL_ISA_X86_ALL   ${DNNL_ISA_X86_ALL}
#cmakedefine DNNL_ISA_VE        ${DNNL_ISA_VE}    // equiv to vanilla
#cmakedefine DNNL_ISA_VE_ALL    ${DNNL_ISA_VE_ALL}
///@}

/// @defgroup cmake_bool derived 0/1 constants
//@{
#define DNNL_TARGET_X86     (DNNL_CPU == DNNL_CPU_X86)
#define DNNL_TARGET_VE      (DNNL_CPU == DNNL_CPU_VE)
#define DNNL_TARGET_VANILLA (DNNL_ISA == DNNL_ISA_VANILLA) // cross-platform
#define DNNL_TARGET_X86_JIT (DNNL_TARGET_X86 && !DNNL_TARGET_VANILLA)
//@}

// clang-format on

#if DNNL_TARGET_X86 + DNNL_TARGET_VE == 0
#error "unknown target cpu.  no DNNL_TARGET_foo was set"
#endif
#if DNNL_TARGET_X86 + DNNL_TARGET_VE != 1
#error "cannot have more than one target cpu"
#endif

#if defined(DNNL_CPU_RUNTIME) && defined(DNNL_GPU_RUNTIME)
#if (DNNL_CPU_RUNTIME == DNNL_RUNTIME_NONE) \
        || (DNNL_CPU_RUNTIME == DNNL_RUNTIME_OCL)
#error "Unexpected DNNL_CPU_RUNTIME"
#endif
#if (DNNL_GPU_RUNTIME != DNNL_RUNTIME_NONE) \
        && (DNNL_GPU_RUNTIME != DNNL_RUNTIME_OCL)
#error "Unexpected DNNL_GPU_RUNTIME"
#endif
#else
#error "BOTH DNNL_CPU_RUNTIME and DNNL_GPU_RUNTIME must be defined"
#endif

// vim: et ts=4 sw=4 cindent cino=+2s,^=l0,\:0,N-s syntax=cpp.doxygen
#endif
